# 路径搜索算法

* Breadth First Search  
* Dijkstra  
* Best First Search  
* A* Algorithm  

## Breadth First Search(广度优先搜索)
* 只能用于基于单位权重图的情况下  
* 根据广度优先搜索的特征，利用队列来存储边界结点集合  
* 能保证找到最短路径  

## Dijkstra
* 相当于广度优先搜索的扩展，能用于正权重图情况下的搜索  
* 根据算法的贪心原理，利用最小堆来存储边界结点集合  
* 能保证找到最短路径  

## Best First Search(最佳优先搜索)
* 最佳优先搜索，是一种启发式搜索算法（Heuristic Algorithm）,我们也可以将它看作广度优先搜索算法的一种改进  
* 最佳优先搜索算法在广度优先搜索的基础上，用启发估价函数对将要被遍历到的点进行估价，然后选择代价小的进行遍历，直到找到目标节点或者遍历完所有结点  
* 当我们在状态空间中搜索的时候，最简单的方法就是穷举，在之前文章提及到的广度优先搜索和深度优先搜索都属于穷举类型的搜索，这种搜索方法有一个很大的缺点，
就是在状态空间十分大的时候效率非常的差，因为需要穷举的状态太多了。而启发式搜索就是对状态空间中的每个搜索的位置进行一个评估，然后选出最好的位置。
而在启发估价中使用到的函数我们称之为启发估价函数。  
* 启发估价函数：f(n) = g(n) + h(n)，其中n为现在所在的节点，g(n)为从起始点到点n的实际代价，h(n)为从点n到目标点的估价。  
* A算法：最佳优先搜索算法我们也称为A算法(algorithm A)  
* A算法不一定能够找到最短距离

## A* Algorithm(A星算法)
* A星算法是Dijkstra算法和A算法的一个trade-off，通过设置启发评估函数可以使得A星算法性能趋向于Dijkstra算法或是A算法  
* 一种极端情况，如果h(n)=0，那么只有g(n)起作用，此时A星算法演变成Dijkstra算法，一定能保证找到最短路径，但是运行效率很慢  
* 如果h(n)小于等于从n到目标的实际代价时，那么A星保证能找到一条最短路径。随着h(n)越小，A星扩展的结点也就越多，运行就慢  
* 如果每次运行让h(n)精确地等于从n到目标的实际代价，那么A星将会仅仅寻找最佳路径而不扩展别的任何结点，这会使得A星算法运行效率非常快，且保证能找到一条最短路径(贪心算法)  
* 如果h(n)大于实际代价的话，则A星算法运行得比之前的快，但是却不一定能找到最佳路径  
* 另一种极端情况，如果h(n)比g(n)大得多，则只有h(n)起作用，A星演变成最佳优先搜索（BFS）算法  

# 上传代码
* 此上传代码是以Java编写，将四种算法封装在Graph类中，在main主函数中直接调用并测试  
* 代码实现时，是在二维单位权重图中实现，当权重为无穷大时代表该路不通(有墙挡着)  

# 参考教程
[Introduction for A star](https://www.redblobgames.com/pathfinding/a-star/introduction.html)
