# 关于字符串匹配算法
----
## 简单字符串匹配
	int matching (string text, string pattern) {
		int n = text.length();
		int m = pattern.length();
		int cnt = 0;
		int j;
		for(int i=0; i<=n-m; i++) {
			j = 0;
			while(j<m && pattern[j]==text[i+j])
				j++;
			if(j>=m){
				//Matched
				cnt++;
			}
		}
	}
* 简单的匹配算法从左到右对text文本进行逐个进行匹配，每次匹配需要进行`O(m)`次比较
* 时间复杂度为：`O(mn)`
* 空间复杂度为：`O(1)`
## KMP算法
* 通过构造一个覆盖数组`next[]`，来记录pattern匹配子串自身的覆盖程度，以当不匹配发生时得到最大的偏移量，减少逐个偏移次数
* 从左向右匹配
* 与覆盖数组相关的是另一种算法DFA（确定有限状态机）
	* KMP算法的可贵之处在于从字符串匹配问题本身出发，巧妙使用覆盖函数这一表征和pattern自身特点来快速生成识别字符串的DFA
* 时间复杂度为：`O(m+n)`
* 空间复杂度为：`O(m)`
## Sunday算法
* 从左向右进行匹配，在匹配失败时关注的是主串中参与匹配的最末位字符的下一位字符
	* 如果该字符没有在模式pattern中出现则直接跳过，即为移动长度为模式串长度+1
	* 否则移动长度=模式串长度-该字符最右出现位置=模式串中该字符最右出现的位置到尾部距离+1
* 偏移表计算
	* ```
	shift[w] = m - max{i < m|P[i] = w},w is in P[0...m-1]
	```
	* ```
	shift[w] = m + 1, otherwise
	```
	* 偏移表下标为字符的ASCII码
* 预处理时间复杂度为：`O(m+|A|), A denotes char set`
* 平均时间复杂度为：`O(n)`
* 空间复杂度为：`O(|A|)`
## BM算法
	j = 0
	while(j <= n - m) {
		for(int i=m; i>=0 && pattern[i]==text[j+i]; i--) {
		}
		if(i < 0) {
			//Matched;
			cnt++;
		} else {
			j += BM();
		}
	}
* 主要特征
	* 从右向左进行比较与匹配
	* 算法分两阶段：预处理阶段和搜索匹配阶段
	* 预处理阶段时间和空间复杂度为`O(m+|A|)`
	* 当模式串是非周期性的，最坏情况下算法要进行3n次字符比较
	* 算法时间复杂度在最好情况下达到`O(n/m)`
* BM算法在移动pattern子串时是从左向右的，进行字符比较时是从右向左的
* BM算法的精华就在于BM(text, pattern),也就是BM算法当不匹配的时候一次性可以跳过不止一个字符。即它不需要对被搜索的字符串中的字符进行逐一比较，而会跳过其中某些部分。通常搜索关键字越长，算法速度越快。它的效率来自于这样的事实：对于每一次失败的匹配尝试，算法都能够使用这些信息来排除尽可能多的无法匹配的位置。即它充分利用待搜索字符串的一些特征，加快了搜索的步骤。
* 两个关键算法
	* 坏字符算法
		* 当出现一个坏字符（不匹配的字符）时，BM算法向右移动模式串，让模式串中最靠右的对于字符与坏字符相对，然后继续匹配
	* 好后缀算法
		* 如果程序匹配了一个好后缀，并且在模式中还有另外一个相同的后缀或后缀的部分，那把下一个后缀或部分后缀移到当前后缀位置
* `BM() = Max{shift(坏字符), shift(好后缀)}`
* 维持两个数组`bmBc[]`和`bmGs[]`，分别表示坏字符算法中需要向右移动的距离和好后缀算法中需要向右移动的距离。其中`bmBc[]`下标是一个字符的ASCII码。
## BMH算法